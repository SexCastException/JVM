/**
 * java四大引用：<p>
 * <b>强引⽤（StrongReference)）</b>：是使用最普遍的引用。如果⼀个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，
 * 使程序异常终止，也不会靠随意回收具有强引⽤的对象来解决内存不足的问题。只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回收。
 * <p>
 * <b>软引用（SoftReference）</b>：介于强引用和弱引用之间；仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用对象。
 * 软引用可以和⼀个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加⼊到与之关联的引用队列中。
 * <p>
 * <b>弱引用（WeakReference）</b>：弱引⽤与软引用的区别在于：只具有弱引用的对象拥有更短暂的⽣命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，
 * ⼀旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。弱引⽤可以和⼀个引用队列（ReferenceQueue）联合使用，
 * 如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加⼊到与之关联的引用队列中。弱引用不建议显示调用垃圾回收达到回收弱引用的作用，
 *
 * <b>虚引用（PhantomReference）</b>：虚引用在任何时候都可能被垃圾回收器回收，主要用来跟踪对象被垃圾回收器回收的活动，被回收时会收到⼀个系统通知。
 * 虚引用与软引用和弱引用的⼀个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收⼀个对象时，如果发现它还有虚引用，
 * 就会在回收对象的内存之前，把这个虚引用加⼊到与之关联的引用队列中，收到系统通知后（notify），再由 ReferenceHandler 线程（本质就是唤醒该线程等待的锁）
 * 回调虚引用相关方法释放资源。例如：直接内存。
 *
 * <b>终结器引用（FinalReference）</b>：无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），
 * 再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 finalize 方法，第二次 GC 时才能回收被引用对象。
 */
package com.huazai.itcast.t2.reference;